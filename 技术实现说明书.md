# 技术实现说明书

## 项目概述
本项目是一个基于 Python 的知识星球文件批量下载工具。它利用 Playwright 框架进行浏览器自动化操作，并通过 PySide6 构建了用户友好的图形界面 (GUI)。项目旨在解决网页端手动下载文件繁琐、无法批量操作以及容易下载错误文件的问题。

## 技术栈
- **编程语言**: Python 3.x
- **GUI 框架**: PySide6 (Qt for Python)
- **自动化框架**: Playwright (基于 Chromium)
- **并发模型**: QThread (分离 UI 线程与后台工作线程)

## 系统架构

### 1. 入口层 (`src/main.py`)
- 程序入口，负责初始化 `QApplication`。
- 加载并显示主窗口 `MainWindow`。
- 设置 Python 路径以确保模块导入正常。

### 2. 界面层 (`src/gui/main_window.py`)
- **MainWindow**: 主窗口类，继承自 `QMainWindow`。
  - **布局**: 左侧为星球订阅列表 (`QListWidget`)，右侧为文件操作区 (`QTableWidget` + 功能按钮) 和日志区 (`QTextEdit`)。
  - **交互**: 处理用户点击事件（刷新、登录、下载、全选等），通过 Signal/Slot 发送指令给 Worker。
  - **状态管理**: 维护当前文件列表数据，根据本地文件是否存在更新按钮状态（“下载” vs “打开位置”）。
- **BrowserWorker**: 后台工作对象，继承自 `QObject`。
  - 运行在独立的 `QThread` 中，避免阻塞 UI。
  - 负责调用核心 API 执行耗时操作（启动浏览器、网络请求、下载文件）。
  - 通过 Signal 将执行结果（日志、列表数据、下载状态）回传给 UI。

### 3. 核心逻辑层 (`src/core/zsxq_api.py`)
- **ZSXQCore**: 封装所有与知识星球网页交互的逻辑。
  - **浏览器管理**: 使用 `launch_persistent_context` 启动持久化浏览器上下文，保存 Cookie 和 LocalStorage，实现免登录复用。
  - **登录检测**: 通过检查 URL 和页面特定元素（如头像、昵称）判断登录状态。
  - **订阅获取**: 注入 JavaScript 脚本扫描侧边栏，提取星球名称和链接。
  - **文件扫描**: 注入 JavaScript 脚本扫描页面 DOM，提取文件名和坐标，支持自动滚动加载。
  - **下载实现**:
    - **精准定位**: 使用 JS 遍历页面元素，进行精确文本匹配 (`text === target`)，避免 Playwright 选择器的模糊匹配导致的错位。
    - **强制滚动**: 找到元素后使用 `scrollIntoView` 确保其可见。
    - **安全校验**: 点击文件后，等待弹窗出现，并**强制校验弹窗标题**。如果弹窗内的文件名与预期不符，立即终止下载，防止由滚动错位导致的错误下载。
    - **下载捕获**: 使用 `page.expect_download()` 捕获浏览器的下载事件。
    - **文件保存**: 自动清理文件名中的非法字符，保存到 `downloads` 目录。
  - **清理机制**: 下载完成后（无论成功失败）及程序退出时，自动清空 `temp_cache` 临时目录。

## 关键流程细节

### 文件下载流程
1. **用户触发**: 用户在 GUI 点击“下载”或“批量下载”。
2. **任务分发**: `MainWindow` 发送 `sig_download` 信号。
3. **核心执行** (`ZSXQCore.download_single_file`):
   - **Step 1: 定位与点击**
     - 注入 JS 函数 `js_click_exact`。
     - 遍历 DOM 寻找 `innerText` 完全等于目标文件名的元素。
     - 找到后调用 `el.scrollIntoView()` 和 `el.click()`。
     - *Fallback*: 如果精确匹配失败，尝试包含匹配（限制容器长度），最后尝试坐标点击。
   - **Step 2: 弹窗校验**
     - 等待“文件详情”弹窗出现。
     - 注入 JS 读取弹窗内容，验证是否包含目标文件名。
     - **熔断机制**: 若标题不匹配，打印 ERROR 日志并返回 False，不执行后续下载。
   - **Step 3: 触发下载**
     - 监听 `download` 事件。
     - 查找弹窗内的“下载”按钮（通过 Locator 或 JS 评分策略）。
     - 点击按钮，等待下载开始。
   - **Step 4: 保存与清理**
     - 获取下载流，保存为目标文件名。
     - 调用 `_cleanup_temp()` 删除临时文件。

### 批量下载流程
1. 用户勾选表格中的复选框。
2. 点击“批量下载选中”。
3. UI 遍历所有勾选行，提取对应的文件对象。
4. 依次发送 `sig_download` 信号。
5. Worker 串行处理下载请求（Playwright 操作需在同一线程串行执行）。

### 历史记忆与文件打开
- **检测**: 在渲染文件列表时，程序根据文件名生成目标路径。
- **判断**: 检查该路径是否存在且文件大小 > 0。
- **反馈**: 若存在，按钮显示为“打开位置”，点击调用系统命令（Windows `explorer /select`, Mac `open -R`）直接定位文件。

## 目录结构
```
d:\aicode\zsxq\
├── src\
│   ├── main.py              # 程序入口
│   ├── gui\
│   │   └── main_window.py   # UI 实现
│   └── core\
│       └── zsxq_api.py      # 核心业务逻辑
├── downloads\               # 下载文件保存区
├── browser_data\            # 浏览器用户数据（Cookie）
└── docs\                    # 文档
```
